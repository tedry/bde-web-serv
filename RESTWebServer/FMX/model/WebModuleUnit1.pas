unit WebModuleUnit1;

interface

uses
  System.SysUtils,
  System.Classes,
  Web.HTTPApp,
  Datasnap.DSHTTPCommon,
  Datasnap.DSHTTPWebBroker,
  Datasnap.DSServer,
  Datasnap.DSSession,
  Web.WebFileDispatcher,
  Web.HTTPProd,
  Datasnap.DSAuth,
  Datasnap.DSProxyJavaScript,
  IPPeerServer,
  Datasnap.DSMetadata,
  Datasnap.DSServerMetadata,
  Datasnap.DSClientMetadata,
  Datasnap.DSCommonServer,
  Datasnap.DSHTTP,
  System.JSON,
  System.JSON.Types,
  System.JSON.Readers,
  Data.DBXCommon;

type
  TByteSet = set of byte;
{$REGION 'WebModule class types'}

  // In this web module, the core role is played by the DSHTTPWebDispatcher component,
  // which is the entry point of the DataSnap and REST requests. This component intercepts
  // any request with a URL starting with ‘datasnap’ (by default), which are passed to the
  // DataSnap server component (DSServer) also included in the web module. For requests
  // starting with ‘datasnap’ and indicating a ‘rest’ path (again a default), the processing will be
  // diverted to the built-in REST engine. In other words, the requests starting with a
  // ‘datasnap/rest’ path are considered as REST requests.
  TWebModule2 = class(TWebModule)
    // DSHTTPWebDispatcher1 is the bridge between the WebBroker architecture and the DataSnap server, as already described.
    DSHTTPWebDispatcher1: TDSHTTPWebDispatcher;

    // ServerFunctionInvoker is a second page producer this time hosting a generic user interface generated from the metadata.
    // The page produced will list all of the methods of the server and let you enter parameters and see the result in JSON
    // format. This page is meant as a development and debugging tool, not for the end user (in fact it will be displayed only
    // if invoked locally).
    ServerFunctionInvoker: TPageProducer;

    ReverseString: TPageProducer;

    // WebFileDispather1 is a WebBroker component (new in Delphi XE) used to return some of the support files (JavaScript files,
    // images, Cascading Style Sheets) generated by the Wizards, and others you can add. A pre-processing event handler
    // of this component will update the serverfunctions.js file every time you recompile and re-execute the application.
    // This JavaScript file contains the “proxy” interface to the methods exposed by the REST server. The file is updated using
    // the support provided by two components: DSProxiGenerator1 & DSServermetaDataProvider1.
    WebFileDispatcher1: TWebFileDispatcher;

    // DSProxiGenerator1 is a new Delphi XE component that you can use to generate the proxy interfaces for various programming
    // languages (Delphi, C++, JavaScript). These are helper classes you can use in those languages to invoke the methods of
    // the REST server easily, without having to manually create the calling URL. In this case the Writer property of the
    // component is set to ‘Java Script REST’. This component works in conjunction with DSServermetaDataProvider1.
    DSProxyGenerator1: TDSProxyGenerator;

    // DSServermetaDataProvider1 offers to the DSProxiGenerator1 component the core metadata of the server. This is a support
    // component with basically no specific settings.
    DSServerMetaDataProvider1: TDSServerMetaDataProvider;
    index: TPageProducer;
    ViewStudents: TPageProducer;
    tile: TPageProducer;
    main: TPageProducer;

    procedure ServerFunctionInvokerHTMLTag(Sender: TObject; Tag: TTag; const TagString: string; TagParams: TStrings; var ReplaceText: string);
    procedure WebModuleDefaultAction(Sender: TObject; Request: TWebRequest; Response: TWebResponse; var Handled: Boolean);
    procedure WebModuleBeforeDispatch(Sender: TObject; Request: TWebRequest; Response: TWebResponse; var Handled: Boolean);
    procedure WebFileDispatcher1BeforeDispatch(Sender: TObject; const AFileName: string; Request: TWebRequest; Response: TWebResponse; var Handled: Boolean);
    procedure WebModuleCreate(Sender: TObject);

    private
      { Private declarations }
      f_GymName_prefetched        : string;
      f_GymAddress_prefetched     : string;
      f_GymEmail_prefetched       : string;
      f_ClassLvl_prefetched       : string;
      f_SelectClassType_prefetched: string;
      f_ClassSchedules_prefetched : string;
      f_ClientEnabled_prefetched  : string;
      FServerFunctionInvokerAction: TWebActionItem;
      function AllowServerFunctionInvoker: Boolean;
    public
      { Public declarations }

  end;
{$ENDREGION}

var
  WebModuleClass: TComponentClass = TWebModule2;
  WebModule     : TWebModule2;

implementation

{%CLASSGROUP 'FMX.Controls.TControl'}
{$R *.dfm}

uses
  ServerMethodsUnit1,
  ServerContainerUnit1,
  Web.WebReq;

{$REGION 'WebModule implementation'}

// -------------------------------------------------------------------------------------------------------------------------------
procedure TWebModule2.WebModuleCreate(Sender: TObject);
begin
  FServerFunctionInvokerAction        := ActionByName('ServerFunctionInvokerAction');
  DSServerMetaDataProvider1.Server    := DSServer_web(self);
  DSHTTPWebDispatcher1.Server         := DSServer_web(self); // intercepts requests and pass them to DataSnap server component
  DSHTTPWebDispatcher1.SessionLifetime:= TDSSessionLifetime.Request;

  f_GymName_prefetched        := '';
  f_GymAddress_prefetched     := '';
  f_ClassLvl_prefetched       := '';
  f_SelectClassType_prefetched:= '';

  if DSServer.Started then
    begin
      DSHTTPWebDispatcher1.DbxContext:= DSServer.DbxContext;
      DSHTTPWebDispatcher1.Start;
    end;
  DSHTTPWebDispatcher1.AuthenticationManager:= DSAuthenticationManager;

  TDSSessionManager.Instance.AddSessionEvent(
    procedure(Sender: TObject; const EventType: TDSSessionEventType; const Session: TDSSession)
    begin
      case EventType of
        SessionCreate: // <-- This fire(s) x2 for each new connector when it connects on the dsport, also once for the web-server instance as well
          begin
            // f_Session:= TDSSessionManager.GetThreadSession; // {Session for the current thread}
          end;
        { The provided Session was just created. }
        SessionClose: // <-- fire(s) x2 for each connector when it disconnects from the dsport, also once for the web-server instance as well
          begin
            // f_Session:= nil;
          end;
        { The provided Session has just been closed, either intentionally or it has expired. }
      end;
    end);

end;

// -------------------------------------------------------------------------------------------------------------------------------
procedure TWebModule2.ServerFunctionInvokerHTMLTag(Sender: TObject; Tag: TTag; const TagString: string; TagParams: TStrings; var ReplaceText: string);
begin
  if SameText(TagString, 'GetGymNameprefetched') then
    ReplaceText:= f_GymName_prefetched
  else if SameText(TagString, 'GetGymAddressprefetched') then
    ReplaceText:= f_GymAddress_prefetched
  else if SameText(TagString, 'GetGymEmailprefetched') then
    ReplaceText:= f_GymEmail_prefetched
  else if SameText(TagString, 'GetClassLvlprefetched') then
    ReplaceText:= f_ClassLvl_prefetched
  else if SameText(TagString, 'GetSelectClassTypeprefetched') then
    ReplaceText:= f_SelectClassType_prefetched
  else if SameText(TagString, 'classschedulesprefetched') then
    ReplaceText:= f_ClassSchedules_prefetched
  else if SameText(TagString, 'ClientEnableprefetched') then
    ReplaceText:= f_ClientEnabled_prefetched
  else if SameText(TagString, 'urlpath') then
    ReplaceText:= string(Request.InternalScriptName)
  else if SameText(TagString, 'port') then
    ReplaceText:= IntToStr(Request.ServerPort)
  else if SameText(TagString, 'host') then
    ReplaceText:= string(Request.Host)
  else if SameText(TagString, 'classname') then
    ReplaceText:= ServerMethodsUnit1.TServerMethods1.ClassName // This one is a class function.. ServerMethods.ClassName // ServerMethodsUnit1.TServerMethods1.ClassName
  else if SameText(TagString, 'loginrequired') then
    // When the loginRequired variable is enabled, the browser-based application hides the
    // standard user interface and displays a login form included in the standard HTML template.
    if DSHTTPWebDispatcher1.AuthenticationManager <> nil then
      ReplaceText:= 'true' // our typical landing spot, so we are telling the html onLoad() loginRequired = 'True'
    else
      ReplaceText:= 'false'
  else if SameText(TagString, 'serverfunctionsjs') then
    ReplaceText:= string(Request.InternalScriptName) + '/js/serverfunctions.js'
  else if SameText(TagString, 'servertime') then
    ReplaceText:= DateTimeToStr(Now)
  else if SameText(TagString, 'serverfunctioninvoker') then
    if AllowServerFunctionInvoker then // if IP is local we allow...
      ReplaceText:= '<div><a href="' + string(Request.InternalScriptName) + '/ServerFunctionInvoker" target="_blank">Server Functions</a></div>'
    else
      ReplaceText:= '';
end;

// -------------------------------------------------------------------------------------------------------------------------------
procedure TWebModule2.WebModuleDefaultAction(Sender: TObject; Request: TWebRequest; Response: TWebResponse; var Handled: Boolean);
// Default action has a very limited role (it will redirect the request or return the default output HTML page normaly Index.html
// Stuff fires 1st in here then migrates up to ServerContainer & then ServerMethods.
var
  s    : string;
  lGUID: string;

  procedure fixup_address(var s: string);
  var
    i   : integer;
    p   : integer;
    done: Boolean;
  begin
    done:= Pos('|', s) = 0;
    i   := 1;
    while not done do
      begin
        p:= Pos('|', s);
        case i of
          1, 3: // Swap '|' with ' ', leave the rest as is.
            begin
              Delete(s, p, 1);
              Insert(' ', s, p);
            end;
          2:
            begin
              Delete(s, p, 1);
              Insert(', ', s, p);
            end;
          4:
            begin
              Delete(s, p, 1);
              Insert(' | ', s, p);
            end;
          5:
            Delete(s, length(s), 1);
        else
          done:= true;
        end;
        inc(i);
        if (i = length(s)) then // safety
          done:= true;
      end;
  end;

  procedure ErrorMsg(const sName: string);
  begin
    Response.Content:= '<html><body><p><b>' + s + '</b> Prefetch Cache query to ' + sName + ' failed to return DataSet.</p></body></html>';
    if Pos('Time-Out', s) <> 0 then
      Response.Content:= Response.Content +
        '<html><body><p>NOTE: The Administrator should check <b>Servers local GUID database </b> for possible errors.</p></body></html>';
    Response.Content:= Response.Content + '<html><body><p><br><strong>Select page refresh/reload to try again.</strong></p></body></html>';
    exit;
  end;

begin
  if (Request.InternalPathInfo = '') or (Request.InternalPathInfo = '/') then // we dont' like this kind of access!
{$IFDEF Debug}
    Response.Content:= '<!DOCTYPE html><html lang=en-us><head><title>Page not found | ProSchool </title>' +
      '<link rel="stylesheet" type="text/css" href="css/401.min.css" /></head>' + '<body><p class=mycss>Direct connections are not allowed<div class=logos2>' +
      '<img src=images/ProSchool4_Logo.png alt="ProSchool 4" class=logos>' +
      '<img src=images/AEG_Logo.png alt="Auburn Electronics Group" class=logos></div></body></html>'
    // Response.StatusCode := 401
    // Response.Content:= '<html><body>Direct connections are not allowed</body></html>'
    // http response 204 No Content https://tools.ietf.org/html/rfc7231#section-6.3.5 We have the option
    // of returning a 204 or 406 code. Which one would be more appropriate? 204 shows a blank page,
    // 406 returns: This page isn’t working If the problem continues, contact the site owner. --alex

    // index.Content { TODO  -oAlex -cShouldDo : Alex - Don't respond or rejected etc. This will stop some web crawlers. }
{$ELSE}
    // Response.StatusCode := 401
      Response.Content:= '<html><body>Directly connecting is not allowed</body></html>'
{$ENDIF Debug}
  else if (Request.InternalPathInfo = '/GUID') or (Request.InternalPathInfo = '/main.html/GUID') then
    begin
      // We MUST always pass a GUID parm on the URL like this:  /GUID?{2267B99A-7E70-4928-9A7C-0A1CECBB7805} so we can pre-fetch
      lGUID:= Request.ContentFields[0];

      // TServerContainer1.SetGUID(FGUID); tbr!!!

      if (lGUID <> '') then
        begin
          // Next we load the prefetched query(s) done in RegisterCheck() all data that we need before a valid LOGIN. They are all pull from local cache db.

          // GymName from Config
          s:= ServerMethods.LocalDBCaheQueryAsString('Select GymName from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('GymName')
          else
            f_GymName_prefetched:= s;

          // GymAddress - Address1, City, State, Zip, Phone, EmailFrom FROM Config
          s:= ServerMethods.LocalDBCaheQueryAsString('Select GymAddress from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('GymAddress')
          else
            f_GymAddress_prefetched:= s;

          // GymEmail
          s:= ServerMethods.LocalDBCaheQueryAsString('Select GymEmail from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('GymEmail')
          else
            f_GymEmail_prefetched:= s;

          // ClassLvl
          s:= ServerMethods.LocalDBCaheQueryAsString('Select ClassLvl from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('ClassLvl')
          else
            f_ClassLvl_prefetched:= s;

          // SelectClassType
          s:= ServerMethods.LocalDBCaheQueryAsString('Select SelectClassType from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('SelectClassType')
          else
            f_SelectClassType_prefetched:= s;

          // ClassSchedules
          s:= ServerMethods.LocalDBCaheQueryAsString('Select ClassSchedules from RegisteredClients where ClientID= :ID', lGUID);
          //s:= ServerMethods.LocalDBCaheQueryAsString( 'Select code, name, type, sunday, monday, tuesday, wednesday, thursday, friday, saturday from Classes where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('ClassSchedules')
          else
            f_ClassSchedules_prefetched:= s;

          // Enable check
          s:= ServerMethods.LocalDBCaheQueryAsString('Select ClientEnabled from RegisteredClients where ClientID= :ID', lGUID);
          if (s = 'NONE') then
            ErrorMsg('ClientEnabled')
          else
            f_ClientEnabled_prefetched:= s; // '1' or '0'
        end;

      // load up the default web-page & show of these prefetched datas f_xxx in the web-page with an tag Example: <#classschedulesprefetched>
      Response.Content:= index.Content;
    end
  else
    Response.SendRedirect(Request.InternalScriptName + '/');
end;

// -------------------------------------------------------------------------------------------------------------------------------
procedure TWebModule2.WebModuleBeforeDispatch(Sender: TObject; Request: TWebRequest; Response: TWebResponse; var Handled: Boolean);
begin
{$IFDEF DEBUG}
  if FServerFunctionInvokerAction <> nil then
    FServerFunctionInvokerAction.Enabled:= AllowServerFunctionInvoker;
{$ENDIF DEBUG}
end;

// -------------------------------------------------------------------------------------------------------------------------------
function TWebModule2.AllowServerFunctionInvoker: Boolean;
begin
  Result:= (Request.RemoteAddr = '127.0.0.1') or (Request.RemoteAddr = '0:0:0:0:0:0:0:1') or (Request.RemoteAddr = '::1');
end;

// -------------------------------------------------------------------------------------------------------------------------------
procedure TWebModule2.WebFileDispatcher1BeforeDispatch(Sender: TObject; const AFileName: string; Request: TWebRequest; Response: TWebResponse;
var Handled: Boolean);
var
  D1, D2: TDateTime;
begin
  Handled:= false;
  if SameFileName(ExtractFileName(AFileName), 'serverfunctions.js') then
   if not FileExists(AFileName) or (FileAge(AFileName, D1) and FileAge(WebApplicationFileName, D2) and (D1 < D2)) then
      begin
        DSProxyGenerator1.TargetDirectory:= ExtractFilePath(AFileName);
        DSProxyGenerator1.TargetUnitName := ExtractFileName(AFileName);
        DSProxyGenerator1.Write;
      end;
end;

{$ENDREGION}

// -------------------------------------------------------------------------------------------------------------------------------
initialization

finalization

Web.WebReq.FreeWebModules;

// -------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------
end.
